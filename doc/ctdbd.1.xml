<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE refentry PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<refentry id="ctdbd.1">

<refmeta>
	<refentrytitle>ctdbd</refentrytitle>
	<manvolnum>1</manvolnum>
</refmeta>


<refnamediv>
	<refname>ctdbd</refname>
	<refpurpose>The CTDB cluster daemon</refpurpose>
</refnamediv>

<refsynopsisdiv>
	<cmdsynopsis>
		<command>ctdbd</command>
	</cmdsynopsis>
	
	<cmdsynopsis>
		<command>ctdbd</command>
		<arg choice="opt">-? --help</arg>
		<arg choice="opt">-d --debug=&lt;INTEGER&gt;</arg>
		<arg choice="req">--dbdir=&lt;directory&gt;</arg>
		<arg choice="req">--dbdir-persistent=&lt;directory&gt;</arg>
		<arg choice="opt">--event-script-dir=&lt;directory&gt;</arg>
		<arg choice="opt">-i --interactive</arg>
		<arg choice="opt">--listen=&lt;address&gt;</arg>
		<arg choice="opt">--logfile=&lt;filename&gt;</arg>
		<arg choice="opt">--lvs</arg>
		<arg choice="req">--nlist=&lt;filename&gt;</arg>
		<arg choice="opt">--no-lmaster</arg>
		<arg choice="opt">--no-recmaster</arg>
		<arg choice="opt">--nosetsched</arg>
		<arg choice="opt">--public-addresses=&lt;filename&gt;</arg>
		<arg choice="opt">--public-interface=&lt;interface&gt;</arg>
		<arg choice="req">--reclock=&lt;filename&gt;</arg>
		<arg choice="opt">--single-public-ip=&lt;address&gt;</arg>
		<arg choice="opt">--socket=&lt;filename&gt;</arg>
		<arg choice="opt">--start-as-disabled</arg>
		<arg choice="opt">--start-as-stopped</arg>
		<arg choice="opt">--syslog</arg>
		<arg choice="opt">--torture</arg>
		<arg choice="opt">--transport=&lt;STRING&gt;</arg>
		<arg choice="opt">--usage</arg>
	</cmdsynopsis>
	
</refsynopsisdiv>

  <refsect1><title>DESCRIPTION</title>
    <para>
      ctdbd is the main ctdb daemon.
    </para>
    <para>
      ctdbd provides a clustered version of the TDB database with automatic rebuild/recovery of the databases upon nodefailures.
    </para>
    <para>
      Combined with a cluster filesystem ctdbd provides a full HA environment for services such as clustered Samba and NFS as well as other services.
    </para>
    <para>
      ctdbd provides monitoring of all nodes in the cluster and automatically reconfigures the cluster and recovers upon node failures.
    </para>
    <para>
      ctdbd is the main component in clustered Samba that provides a high-availability load-sharing CIFS server cluster.
    </para>
  </refsect1>


  <refsect1>
    <title>OPTIONS</title>

    <variablelist>
      <varlistentry><term>-? --help</term>
        <listitem>
          <para>
            Print some help text to the screen.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>-d --debug=&lt;DEBUGLEVEL&gt;</term>
        <listitem>
          <para>
            This option sets the debuglevel on the ctdbd daemon which controls what will be written to the logfile. The default is 0 which will only log important events and errors. A larger number will provide additional logging.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--dbdir=&lt;directory&gt;</term>
        <listitem>
          <para>
            This is the directory on local storage where ctdbd keeps the local
            copy of the TDB databases. This directory is local for each node and should not be stored on the shared cluster filesystem.
          </para>
          <para>
            This directory would usually be /var/ctdb .
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--dbdir-persistent=&lt;directory&gt;</term>
        <listitem>
          <para>
            This is the directory on local storage where ctdbd keeps the local
            copy of the persistent TDB databases. This directory is local for each node and should not be stored on the shared cluster filesystem.
          </para>
          <para>
            This directory would usually be /etc/ctdb/persistent .
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--event-script-dir=&lt;directory&gt;</term>
        <listitem>
          <para>
            This option is used to specify the directory where the CTDB event
	    scripts are stored.
          </para>
          <para>
            This will normally be /etc/ctdb/events.d which is part of the ctdb distribution.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>-i --interactive</term>
        <listitem>
          <para>
            By default ctdbd will detach itself from the shell and run in
            the background as a daemon. This option makes ctdbd to start in interactive mode.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--listen=&lt;address&gt;</term>
        <listitem>
          <para>
            This specifies which ip address ctdb will bind to. By default ctdbd will bind to the first address it finds in the /etc/ctdb/nodes file and which is also present on the local system in which case you do not need to provide this option.
          </para>
          <para>
            This option is only required when you want to run multiple ctdbd daemons/nodes on the same physical host in which case there would be multiple entries in /etc/ctdb/nodes what would match a local interface.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--logfile=&lt;filename&gt;</term>
        <listitem>
          <para>
            This is the file where ctdbd will write its log. This is usually /var/log/log.ctdb .
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--lvs</term>
        <listitem>
          <para>
	  This option is used to activate the LVS capability on a CTDB node.
	  Please see the LVS section.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--nlist=&lt;filename&gt;</term>
        <listitem>
          <para>
            This file contains a list of the private ip addresses of every node in the cluster. There is one line/ip address for each node. This file must be the same for all nodes in the cluster.
          </para>
          <para>
            This file is usually /etc/ctdb/nodes .
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--no-lmaster</term>
        <listitem>
          <para>
	  This argument specifies that this node can NOT become an lmaster
	  for records in the database. This means that it will never show up
	  in the vnnmap. This feature is primarily used for making a cluster
	span across a WAN link and use CTDB as a WAN-accelerator.
          </para>
          <para>
	  Please see the "remote cluster nodes" section for more information.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--no-recmaster</term>
        <listitem>
          <para>
	  This argument specifies that this node can NOT become a recmaster
	  for the database. This feature is primarily used for making a cluster
	span across a WAN link and use CTDB as a WAN-accelerator.
          </para>
          <para>
	  Please see the "remote cluster nodes" section for more information.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--nosetsched</term>
        <listitem>
          <para>
	    This is a ctdbd debugging option. this option is only used when
	    debugging ctdbd.
	  </para>
	  <para>
            Normally ctdb will change its scheduler to run as a real-time 
	    process. This is the default mode for a normal ctdbd operation
	    to gurarantee that ctdbd always gets the cpu cycles that it needs.
          </para>
          <para>
	    This option is used to tell ctdbd to NOT run as a real-time process
	    and instead run ctdbd as a normal userspace process.
	    This is useful for debugging and when you want to run ctdbd under
	    valgrind or gdb. (You dont want to attach valgrind or gdb to a
	    real-time process.)
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--public_addresses=&lt;filename&gt;</term>
        <listitem>
          <para>
            When used with IP takeover this specifies a file containing the public ip addresses to use on the cluster. This file contains a list of ip addresses netmasks and interfaces. When ctdb is operational it will distribute these public ip addresses evenly across the available nodes.
          </para>
          <para>
            This is usually the file /etc/ctdb/public_addresses
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--public-interface=&lt;interface&gt;</term>
        <listitem>
          <para>
            This option tells ctdb which interface to attach public-addresses
	    to and also where to attach the single-public-ip when used.
	    </para>
	    <para>
	    This is only required when using public ip addresses and only when
	    you dont specify the interface explicitly in /etc/ctdb/public_addresses or when you are using --single-public-ip.
          </para>
          <para>
	  If you omit this argument when using public addresses or single public ip, ctdb will not be able to send out Gratious ARPs correctly or be able to kill tcp connections correctly which will lead to application failures. 
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--reclock=&lt;filename&gt;</term>
        <listitem>
          <para>
            This is the name of the lock file stored of the shared cluster filesystem that ctdbd uses to prevent split brains from occuring.
            This file must be stored on shared storage.
          </para>
          <para>
	    It is possible to run CTDB without a reclock file, but then there 
	    will be no protection against split brain if the network becomes
	    partitioned. Using CTDB without a reclock file is strongly
	    discouraged.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--socket=&lt;filename&gt;</term>
        <listitem>
          <para>
            This specifies the name of the domain socket that ctdbd will create. This socket is used for local clients to attach to and communicate with the ctdbd daemon.
          </para>
          <para>
            The default is /tmp/ctdb.socket . You only need to use this option if you plan to run multiple ctdbd daemons on the same physical host.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--start-as-disabled</term>
        <listitem>
          <para>
	  This makes the ctdb daemon to be DISABLED when it starts up.
          </para>
          <para>
	  As it is DISABLED it will not get any of the public ip addresses
	  allocated to it, and thus this allow you to start ctdb on a node 
	  without causing any ip address to failover from other nodes onto
	  the new node.
          </para>
          <para>
	  When used, the administrator must keep track of when nodes start and
	  manually enable them again using the "ctdb enable" command, or else
	  the node will not host any services.
          </para>
          <para>
	  A node that is DISABLED will not host any services and will not be
	  reachable/used by any clients.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--start-as-stopped</term>
        <listitem>
          <para>
	  This makes the ctdb daemon to be STOPPED when it starts up.
          </para>
          <para>
	  A node that is STOPPED does not host any public addresses. It is not part of the VNNMAP so it does act as an LMASTER. It also has all databases locked in recovery mode until restarted.
          </para>
          <para>
	  To restart and activate a STOPPED node, the command "ctdb continue" is used.
          </para>
          <para>
	  A node that is STOPPED will not host any services and will not be
	  reachable/used by any clients.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--syslog</term>
        <listitem>
          <para>
	    Send all log messages to syslog instead of to the ctdb logfile.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--torture</term>
        <listitem>
          <para>
            This option is only used for development and testing of ctdbd. It adds artificial errors and failures to the common codepaths in ctdbd to verify that ctdbd can recover correctly for failures.
          </para>
          <para>
            You do NOT want to use this option unless you are developing and testing new functionality in ctdbd.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--transport=&lt;STRING&gt;</term>
        <listitem>
          <para>
            This option specifies which transport to use for ctdbd internode communications. The default is "tcp".
          </para>
          <para>
            Currently only "tcp" is supported but "infiniband" might be
	    implemented in the future.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry><term>--usage</term>
        <listitem>
          <para>
            Print useage information to the screen.
          </para>
        </listitem>
      </varlistentry>

    </variablelist>
  </refsect1>


  <refsect1><title>Private vs Public addresses</title>
    <para>
      When used for ip takeover in a HA environment, each node in a ctdb 
      cluster has multiple ip addresses assigned to it. One private and one or more public.
    </para>

    <refsect2><title>Private address</title>
      <para>
        This is the physical ip address of the node which is configured in 
        linux and attached to a physical interface. This address uniquely
        identifies a physical node in the cluster and is the ip addresses
        that ctdbd will use to communicate with the ctdbd daemons on the
        other nodes in the cluster.
      </para>
      <para>
        The private addresses are configured in /etc/ctdb/nodes 
        (unless the --nlist option is used) and contain one line for each 
        node in the cluster. Each line contains the private ip address for one
        node in the cluster. This file must be the same on all nodes in the
	cluster.
      </para>
      <para>
        Since the private addresses are only available to the network when the
        corresponding node is up and running you should not use these addresses
        for clients to connect to services provided by the cluster. Instead
        client applications should only attach to the public addresses since
        these are guaranteed to always be available.
      </para>
      <para>
        When using ip takeover, it is strongly recommended that the private 
	addresses are configured on a private network physically separated
	from the rest of the network and that this private network is dedicated
	to CTDB traffic.
      </para>
      Example /etc/ctdb/nodes for a four node cluster:
      <screen format="linespecific">
        10.1.1.1
        10.1.1.2
        10.1.1.3
        10.1.1.4
      </screen>
    </refsect2>
    <refsect2><title>Public address</title>
      <para>
        A public address on the other hand is not attached to an interface.
        This address is managed by ctdbd itself and is attached/detached to
        a physical node at runtime.
      </para>
      <para>
        The ctdb cluster will assign/reassign these public addresses across the
        available healthy nodes in the cluster. When one node fails, its public address
        will be migrated to and taken over by a different node in the cluster
        to ensure that all public addresses are always available to clients as 
	long as there are still nodes available capable of hosting this address.
      </para>
      <para>
        These addresses are not physically attached to a specific node. 
        The 'ctdb ip' command can be used to view the current assignment of 
        public addresses and which physical node is currently serving it.
      </para>
      <para>
	On each node this file contains a list of the public addresses that 
	this node is capable of hosting.
        The list also contain the netmask and the 
	interface where this address should be attached for the case where you
	may want to serve data out through multiple different interfaces.
      </para>
      Example /etc/ctdb/public_addresses for a node that can host 4 public addresses:
      <screen format="linespecific">
        11.1.1.1/24 eth0
        11.1.1.2/24 eth0
        11.1.2.1/24 eth1
        11.1.2.2/24 eth1
      </screen>

	<para>
	In most cases this file would be the same on all nodes in a cluster but
	there are exceptions when one may want to use different files
	on different nodes.
	</para>
	Example: 4 nodes partitioned into two subgroups :
	<screen format="linespecific">
	Node 0:/etc/ctdb/public_addresses
		10.1.1.1/24 eth0
		10.1.1.2/24 eth0

	Node 1:/etc/ctdb/public_addresses
		10.1.1.1/24 eth0
		10.1.1.2/24 eth0

	Node 2:/etc/ctdb/public_addresses
		10.2.1.1/24 eth0
		10.2.1.2/24 eth0

	Node 3:/etc/ctdb/public_addresses
		10.2.1.1/24 eth0
		10.2.1.2/24 eth0
	</screen>
	<para>
	In this example nodes 0 and 1 host two public addresses on the 
	10.1.1.x network  while nodes 2 and 3 host two public addresses for the 
	10.2.1.x network.
	</para>
	<para>
	Ip address 10.1.1.1 can be hosted by either of nodes 0 or 1 and will be
	available to clients as long as at least one of these two nodes are
	available.
	If both nodes 0 and node 1 become unavailable 10.1.1.1 also becomes 
	unavailable. 10.1.1.1 can not be failed over to node 2 or node 3 since
	these nodes do not have this ip address listed in their public
	addresses file.
	</para>
    </refsect2>
  </refsect1>


  <refsect1><title>Node status</title>
    <para>
      The current status of each node in the cluster can be viewed by the 
      'ctdb status' command.
    </para>
    <para>
      There are five possible states for a node.
    </para>

    <para>
      OK - This node is fully functional.
    </para>
    
    <para>
      DISCONNECTED - This node could not be connected through the network 
      and is currently not particpating in the cluster. If there is a 
      public IP address associated with this node it should have been taken 
      over by a different node. No services are running on this node.
    </para>
 
    <para>
      DISABLED - This node has been administratively disabled. This node is 
      still functional and participates in the CTDB cluster but its IP 
      addresses have been taken over by a different node and no services are 
      currently being hosted.
    </para>
   
    <para>
      UNHEALTHY - A service provided by this node is malfunctioning and should 
      be investigated. The CTDB daemon itself is operational and participates 
      in the cluster. Its public IP address has been taken over by a different 
      node and no services are currently being hosted. All unhealthy nodes 
      should be investigated and require an administrative action to rectify.
    </para>
    
    <para>
      BANNED - This node failed too many recovery attempts and has been banned 
      from participating in the cluster for a period of RecoveryBanPeriod 
      seconds. Any public IP address has been taken over by other nodes. This 
      node does not provide any services. All banned nodes should be 
      investigated and require an administrative action to rectify. This node 
      does not perticipate in the CTDB cluster but can still be communicated 
      with. I.e. ctdb commands can be sent to it.
    </para>

    <para>
      STOPPED - A node that is stopped does not host any public ip addresses,
      nor is it part of the VNNMAP. A stopped node can not become LVSMASTER,
      RECMASTER or NATGW.
      This node does not perticipate in the CTDB cluster but can still be
      communicated with. I.e. ctdb commands can be sent to it.
    </para>
  </refsect1>

  <refsect1>
    <title>PUBLIC TUNABLES</title>
    <para>
    These are the public tuneables that can be used to control how ctdb behaves.
    </para>

    <refsect2><title>KeepaliveInterval</title>
    <para>Default: 1</para>
    <para>
    How often should the nodes send keepalives to eachother.
    </para>
    </refsect2>
    <refsect2><title>KeepaliveLimit</title>
    <para>Default: 5</para>
    <para>
    After how many keepalive intervals without any traffic should a node
    wait until marking the peer as DISCONNECTED.
    </para>
    </refsect2>
    <refsect2><title>MonitorInterval</title>
    <para>Default: 15</para>
    <para>
    How often should ctdb run the event scripts to check for a nodes health.
    </para>
    </refsect2>
    <refsect2><title>TickleUpdateInterval</title>
    <para>Default: 20</para>
    <para>
    How often will ctdb record and store the "tickle" information used to
    kickstart stalled tcp connections after a recovery.
    </para>
    </refsect2>
    <refsect2><title>EventScriptTimeout</title>
    <para>Default: 20</para>
    <para>
    How long should ctdb let an event script run before aborting it and
    marking the node unhealthy.
    </para>
    </refsect2>
    <refsect2><title>RecoveryBanPeriod</title>
    <para>Default: 300</para>
    <para>
    If a node becomes banned causing repetitive recovery failures. The node will
    eventually become banned from the cluster.
    This controls how long the culprit node will be banned from the cluster
    before it is allowed to try to join the cluster again.
    Dont set to small. A node gets banned for a reason and it is usually due
    to real problems with the node.
    </para>
    </refsect2>
    <refsect2><title>DatabaseHashSize</title>
    <para>Default: 100000</para>
    <para>
    Size of the hash chains for the local store of the tdbs that ctdb manages.
    </para>
    </refsect2>
    <refsect2><title>RerecoveryTimeout</title>
    <para>Default: 10</para>
    <para>
    Once a recovery has completed, no additional recoveries are permitted until this timeout has expired.
    </para>
    </refsect2>
    <refsect2><title>EnableBans</title>
    <para>Default: 1</para>
    <para>
    When set to 0, this disables BANNING completely in the cluster and thus nodes can not get banned, even it they break. Dont set to 0.
    </para>
    </refsect2>
    <refsect2><title>DeterministicIPs</title>
    <para>Default: 1</para>
    <para>
    When enabled, this tunable makes ctdb try to keep public IP addresses locked to specific nodes as far as possible. This makes it easier for debugging since you can know that as long as all nodes are healthy public IP X will always be hosted by node Y. 
    </para>
    <para>
    The cost of using deterministic IP address assignment is that it disables part of the logic where ctdb tries to reduce the number of public IP assignment changes in the cluster. This tunable may increase the number of IP failover/failbacks that are performed on the cluster by a small margin.
    </para>
    </refsect2>
    <refsect2><title>DisableWhenUnhealthy</title>
    <para>Default: 0</para>
    <para>
    When set, As soon as a node becomes unhealthy, that node will also automatically become permanently DISABLED. Once a node is DISABLED, the only way to make it participate in the cluster again and host services is by manually enabling the node again using 'ctdb enable'. 
    </para>
    <para>
    This disables parts of the resilience and robustness of the cluster and should ONLY be used when the system administrator is actively monitoring the cluster, so that nodes can be enabled again.
    </para>
    </refsect2>
    <refsect2><title>NoIPFailback</title>
    <para>Default: 0</para>
    <para>
    When set to 1, ctdb will not perform failback of IP addresses when a node becomes healthy. Ctdb WILL perform failover of public IP addresses when a node becomes UNHEALTHY, but when the node becomes HEALTHY again, ctdb will not fail the addresses back.
    </para>
    <para>
    Use with caution! Normally when a node becomes available to the cluster
ctdb will try to reassign public IP addresses onto the new node as a way to distribute the workload evenly across the clusternode. Ctdb tries to make sure that all running nodes have approximately the same number of public addresses it hosts.
    </para>
    <para>
    When you enable this tunable, CTDB will no longer attempt to rebalance the cluster by failing IP addresses back to the new nodes. An unbalanced cluster will therefore remain unbalanced until there is manual intervention from the administrator. When this parameter is set, you can manually fail public IP addresses over to the new node(s) using the 'ctdb moveip' command.
    </para>
    </refsect2>
  </refsect1>

  <refsect1><title>LVS</title>
    <para>
    LVS is a mode where CTDB presents one single IP address for the entire
    cluster. This is an alternative to using public IP addresses and round-robin
    DNS to loadbalance clients across the cluster.
    </para>

    <para>
    This is similar to using a layer-4 loadbalancing switch but with some restrictions.
    </para>

    <para>
    In this mode the cluster select a set of nodes in the cluster and loadbalance
    all client access to the LVS address across this set of nodes. This set of nodes are all LVS capable nodes that are HEALTHY, or if no HEALTHY nodes exists
    all LVS capable nodes regardless of health status.
    LVS will however never loadbalance traffic to nodes that are BANNED,
    STOPPED, DISABLED or DISCONNECTED. The "ctdb lvs" command is used to show
    which nodes are currently load-balanced across.
    </para>

    <para>
    One of the these nodes are elected as the LVSMASTER. This node receives all
    traffic from clients coming in to the LVS address and multiplexes it
    across the internal network to one of the nodes that LVS is using.
    When responding to the client, that node will send the data back
    directly to the client, bypassing the LVSMASTER node.
    The command "ctdb lvsmaster" will show which node is the current
    LVSMASTER.
    </para>

    <para>
    The path used for a client i/o is thus :
    <screen format="linespecific">
	(1) Client sends request packet to LVSMASTER
	(2) LVSMASTER passes the request on to one node across the internal network.
	(3) Selected node processes the request.
	(4) Node responds back to client.
    </screen>
    </para>

    <para> 
    This means that all incoming traffic to the cluster will pass through
    one physical node, which limits scalability. You can send more data to the
    LVS address that one physical node can multiplex. This means that you 
    should not use LVS if your I/O pattern is write-intensive since you will be
    limited in the available network bandwidth that node can handle.
    LVS does work wery well for read-intensive workloads where only smallish
    READ requests are going through the LVSMASTER bottleneck and the majority
    of the traffic volume (the data in the read replies) goes straight from
    the processing node back to the clients. For read-intensive i/o patterns you can acheive very high throughput rates in this mode.
    </para>

    <para>
    Note: you can use LVS and public addresses at the same time.
    </para>

    <refsect2><title>Configuration</title>
	<para>
    To activate LVS on a CTDB node you must specify CTDB_PUBLIC_INTERFACE and 
    CTDB_LVS_PUBLIC_ADDRESS in /etc/sysconfig/ctdb.
	</para>

	<para>
You must also specify the "--lvs" command line argument to ctdbd to activete LVS as a capability of the node. This should be done automatically for you by the /etc/init.d/ctdb script.
	</para>

	<para>
	Example:
    <screen format="linespecific">
	CTDB_PUBLIC_INTERFACE=eth0
	CTDB_LVS_PUBLIC_IP=10.0.0.237
	</screen>
	</para>

    </refsect2>

    <para>
    If you use LVS, you must still have a real/permanent address configured
    for the public interface on each node. This address must be routable
    and the cluster nodes must be configured so that all traffic back to client
    hosts are routed through this interface. This is also required in order
    to allow samba/winbind on the node to talk to the domain controller.
    (we can not use the lvs IP address to initiate outgoing traffic)
    </para>
    <para>
    I.e. make sure that you can "ping" both the domain controller and also
    all of the clients from the node BEFORE you enable LVS. Also make sure
    that when you ping these hosts that the traffic is routed out through the
    eth0 interface.
    </para>
  </refsect1>
    

  <refsect1><title>REMOTE CLUSTER NODES</title>
    <para>
It is possible to have a CTDB cluster that spans across a WAN link. 
For example where you have a CTDB cluster in your datacentre but you also
want to have one additional CTDB node located at a remote branch site.
This is similar to how a WAN accelerator works but with the difference 
that while a WAN-accelerator often acts as a Proxy or a MitM, in 
the ctdb remote cluster node configuration the Samba instance at the remote site
IS the genuine server, not a proxy and not a MitM, and thus provides 100%
correct CIFS semantics to clients.
    </para>

    <para>
	See the cluster as one single multihomed samba server where one of
	the NICs (the remote node) is very far away.
    </para>

    <para>
	NOTE: This does require that the cluster filesystem you use can cope
	with WAN-link latencies. Not all cluster filesystems can handle
	WAN-link latencies! Whether this will provide very good WAN-accelerator
	performance or it will perform very poorly depends entirely
	on how optimized your cluster filesystem is in handling high latency
	for data and metadata operations.
    </para>

    <para>
	To activate a node as being a remote cluster node you need to set
	the following two parameters in /etc/sysconfig/ctdb  for the remote node:
        <screen format="linespecific">
CTDB_CAPABILITY_LMASTER=no
CTDB_CAPABILITY_RECMASTER=no
	</screen>
    </para>

    <para>
	Verify with the command "ctdb getcapabilities" that that node no longer
	has the recmaster or the lmaster capabilities.
    </para>

  </refsect1>


  <refsect1><title>NAT-GW</title>
    <para>
      Sometimes it is desireable to run services on the CTDB node which will
      need to originate outgoing traffic to external servers. This might
      be contacting NIS servers, LDAP servers etc. etc.
    </para>
    <para>
      This can sometimes be problematic since there are situations when a
      node does not have any public ip addresses assigned. This could
      be due to the nobe just being started up and no addresses have been
      assigned yet or it could be that the node is UNHEALTHY in which
      case all public addresses have been migrated off.
    </para>
    <para>
      If then the service status of CTDB depends on such services being
      able to always being able to originate traffic to external resources
      this becomes extra troublesome. The node might be UNHEALTHY because
      the service can not be reached, and the service can not be reached
      because the node is UNHEALTHY.
    </para>
    <para>
      There are two ways to solve this problem. The first is by assigning a
      static ip address for one public interface on every node which will allow
      every node to be able to route traffic to the public network even
      if there are no public addresses assigned to the node.
      This is the simplest way but it uses up a lot of ip addresses since you
      have to assign both static and also public addresses to each node.
    </para>
    <refsect2><title>NAT-GW</title>
    <para>
      A second way is to use the built in NAT-GW feature in CTDB.
      With NAT-GW you assign one public NATGW address for each natgw group.
      Each NATGW group is a set of nodes in the cluster that shares the same
      NATGW address to talk to the outside world. Normally there would only be
      one NATGW group spanning the entire cluster, but in situations where one
      ctdb cluster spans multiple physical sites it is useful to have one
      NATGW group for each of the two sites.
    </para>
    <para>
      There can be multiple NATGW groups in one cluster but each node can only
      be member of one NATGW group.
    </para>
    <para>
      In each NATGW group, one of the nodes is designated the NAT Gateway
      through which all traffic that is originated by nodes in this group
      will be routed through if a public addresses are not available. 
    </para>
    </refsect2>

    <refsect2><title>Configuration</title>
    <para>
      NAT-GW is configured in /etc/sysconfigctdb by setting the following
      variables:
    </para>
    <screen format="linespecific">
# NAT-GW configuration
# Some services running on nthe CTDB node may need to originate traffic to
# remote servers before the node is assigned any IP addresses,
# This is problematic since before the node has public addresses the node might
# not be able to route traffic to the public networks.
# One solution is to have static public addresses assigned with routing
# in addition to the public address interfaces, thus guaranteeing that
# a node always can route traffic to the external network.
# This is the most simple solution but it uses up a large number of 
# additional ip addresses.
#
# A more complex solution is NAT-GW.
# In this mode we only need one additional ip address for the cluster from
# the exsternal public network.
# One of the nodes in the cluster is elected to be hosting this ip address
# so it can reach the external services. This node is also configured
# to use NAT MASQUERADING for all traffic from the internal private network
# to the external network. This node is the NAT-GW node.
#
# All other nodes are set up with a default rote with a metric of 10 to point
# to the nat-gw node.
# 
# The effect of this is that only when a node does not have a public address
# and thus no proper routes to the external world it will instead
# route all packets through the nat-gw node.
#
# CTDB_NATGW_NODES is the list of nodes that belong to this natgw group.
# You can have multiple natgw groups in one cluster but each node
# can only belong to one single natgw group.
#
# CTDB_NATGW_PUBLIC_IP=10.0.0.227/24
# CTDB_NATGW_PUBLIC_IFACE=eth0
# CTDB_NATGW_DEFAULT_GATEWAY=10.0.0.1
# CTDB_NATGW_PRIVATE_NETWORK=10.1.1.0/24
# CTDB_NATGW_NODES=/etc/ctdb/natgw_nodes
    </screen>
    </refsect2>

    <refsect2><title>CTDB_NATGW_PUBLIC_IP</title>
    <para>
      This is an ip address in the public network that is used for all outgoing
      traffic when the public addresses are not assigned.
      This address will be assigned to one of the nodes in the cluster which
      will masquerade all traffic for the other nodes.
    </para>
    <para>
      Format of this parameter is IPADDRESS/NETMASK
    </para>
    </refsect2>

    <refsect2><title>CTDB_NATGW_PUBLIC_IFACE</title>
    <para>
      This is the physical interface where the CTDB_NATGW_PUBLIC_IP will be
      assigned to. This should be an interface connected to the public network.
    </para>
    <para>
      Format of this parameter is INTERFACE
    </para>
    </refsect2>

    <refsect2><title>CTDB_NATGW_DEFAULT_GATEWAY</title>
    <para>
      This is the default gateway to use on the node that is elected to host
      the CTDB_NATGW_PUBLIC_IP. This is the default gateway on the public network.
    </para>
    <para>
      Format of this parameter is IPADDRESS
    </para>
    </refsect2>

    <refsect2><title>CTDB_NATGW_PRIVATE_NETWORK</title>
    <para>
      This is the network/netmask used for the interal private network.
    </para>
    <para>
      Format of this parameter is IPADDRESS/NETMASK
    </para>
    </refsect2>

    <refsect2><title>CTDB_NATGW_NODES</title>
    <para>
      This is the list of all nodes that belong to the same NATGW group
      as this node. The default is /etc/ctdb/natgw_nodes.
    </para>
    </refsect2>

    <refsect2><title>Operation</title>
    <para>
      When the NAT-GW functionality is used, one of the nodes is elected
      to act as a NAT router for all the other nodes in the group when
      they need to originate traffic to the external public network.
    </para>
    <para>
      The NAT-GW node is assigned the CTDB_NATGW_PUBLIC_IP to the designated
      interface and the provided default route. The NAT-GW is configured
      to act as a router and to masquerade all traffic it receives from the
      internal private network and which is destined to the external network(s).
    </para>
    <para>
      All other nodes in the group are configured with a default route of
      metric 10 pointing to the designated NAT GW node.
    </para>
    <para>
      This is implemented in the 11.natgw eventscript. Please see the
      eventscript for further information.
    </para>
    </refsect2>

    <refsect2><title>Activating NATGW without forcing a cluster restart</title>
    <para>
      Normally you would update the configuration and restart the nodes to activate NATGW. It is however also possible to manually start NATGW without restarting CTDB, but it does require a recovery.
    </para>
    <para>
      To activate NATGW functionality on a cluster without restarting the actual nodes you can use the following process :
    </para>
    <variablelist>
      <varlistentry><term>Activating NATGW on a running system</term>
        <listitem>
          <para>
            Configure NATGW as described above on all nodes.
          </para>
        </listitem>
        <listitem>
          <para>
            Run "echo 3 > /proc/sys/net/ipv4/conf/all/arp_ignore" on all nodes.
          </para>
        </listitem>
        <listitem>
          <para>
            Run "echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce" on all nodes.
          </para>
        </listitem>
        <listitem>
          <para>
            Force a recovery by running "ctdb recover".
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    </refsect2>

  </refsect1>



<refsect1><title>ClamAV Daemon</title>
<para>
CTDB has support to manage the popular anti-virus daemon ClamAV.
This support is implemented through the
eventscript : /etc/ctdb/events.d/31.clamd.
</para>
      
<refsect2><title>Configuration</title>
<para>
Start by configuring CLAMAV normally and test that it works. Once this is
done, copy the configuration files over to all the nodes so that all nodes
share identical CLAMAV configurations.
Once this is done you can proceed with the intructions below to activate
CTDB support for CLAMAV.
</para>

<para>
First, to activate CLAMAV support in CTDB, edit /etc/sysconfig/ctdb and add the two lines :
</para>
<screen format="linespecific">
CTDB_MANAGES_CLAMD=yes
CTDB_CLAMD_SOCKET="/path/to/clamd.socket"
</screen>

<para>
Second, activate the eventscript by making it executable:
</para>
<screen format="linespecific">
chmod +x /etc/ctdb/events.d/31.clamd
</screen>

<para>
Third, CTDB will now be starting and stopping this service accordingly,
so make sure that the system is not configured to start/stop this service
automatically.
On RedHat systems you can disable the system starting/stopping CLAMAV automatically by running :
<screen format="linespecific">
chkconfig clamd off
</screen>
</para>


<para>
Once you have restarted CTDBD, use
<screen format="linespecific">
ctdb scriptstatus
</screen>
and verify that the 31.clamd eventscript is listed and that it was executed successfully.
</para>

</refsect2>
</refsect1>




  <refsect1><title>SEE ALSO</title>
    <para>
      ctdb(1), onnode(1)
      <ulink url="http://ctdb.samba.org/"/>
    </para>
  </refsect1>

  <refsect1><title>COPYRIGHT/LICENSE</title>
<literallayout>
Copyright (C) Andrew Tridgell 2007
Copyright (C) Ronnie sahlberg 2007

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see http://www.gnu.org/licenses/.
</literallayout>
  </refsect1>
</refentry>

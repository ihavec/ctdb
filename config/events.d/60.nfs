#!/bin/sh
# script to manage nfs in a clustered environment

. /etc/ctdb/functions
loadconfig nfs

[ "$CTDB_MANAGES_NFS" = "yes" ] || exit 0
[ -z "$STATD_SHARED_DIRECTORY" ] && exit 0

cmd="$1"
shift

PATH=/usr/bin:/bin:/usr/sbin:/sbin:$PATH

case $cmd in 
     startup)
	/bin/mkdir -p /etc/ctdb/state/nfs
	/bin/mkdir -p /etc/ctdb/state/statd/ip
	/bin/mkdir -p $STATD_SHARED_DIRECTORY
	ctdb_wait_directories "nfslock" "$STATD_SHARED_DIRECTORY"


	# wait for all nfs exported directories to become available
	nfs_dirs=`grep -v '^#' < /etc/exports | cut -d' ' -f1`
	ctdb_wait_directories "NFS" $nfs_dirs

	# make sure nfs is stopped before we start it, or it may get a bind error
	service nfs stop > /dev/null 2>&1
	service nfslock stop > /dev/null 2>&1

	service nfslock start
	service nfs start
	;;

     shutdown)
	service nfs stop
	service nfslock stop
	exit 0
	;;

     takeip)
	ip=$2

	echo $ip >> /etc/ctdb/state/statd/restart

	# having a list of what IPs we have allows statd to do the right 
	# thing via /etc/ctdb/statd-callout
	/bin/touch /etc/ctdb/state/statd/ip/$ip
	exit 0
	;;

     releaseip)
	iface=$1
	ip=$2
	maskbits=$3

	echo $ip >> /etc/ctdb/state/nfs/restart

	echo $ip >> /etc/ctdb/state/statd/restart
	/bin/rm -f /etc/ctdb/state/statd/ip/$ip
	exit 0
	;;

     recovered)
	[ -f /etc/ctdb/state/nfs/restart ] && [ ! -z "$LOCKD_TCPPORT" ] && {
	        # RST all tcp connections used for NLM to ensure that they do
		# not survive in ESTABLISHED state across a failover/failback
		# and create an ack storm
		netstat -tn |egrep "^tcp.*\s+[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:${LOCKD_TCPPORT}\s+.*ESTABLISHED" | awk '{print $4" "$5}' | while read dest src; do
			srcip=`echo $src | cut -d: -f1`
			srcport=`echo $src | cut -d: -f2`
			destip=`echo $dest | cut -d: -f1`
			destport=`echo $dest | cut -d: -f2`
			ctdb killtcp $srcip:$srcport $destip:$destport >/dev/null 2>&1 
#			ctdb killtcp $destip:$destport $srcip:$srcport >/dev/null 2>&1
		done
	} > /dev/null 2>&1

	[ -f /etc/ctdb/state/nfs/restart ] && {
	        # RST all tcp connections used for NFS to ensure that they do
		# not survive in ESTABLISHED state across a failover/failback
		# and create an ack storm
		netstat -tn |egrep '^tcp.*\s+[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:2049\s+.*ESTABLISHED' | awk '{print $4" "$5}' | while read dest src; do
			srcip=`echo $src | cut -d: -f1`
			srcport=`echo $src | cut -d: -f2`
			destip=`echo $dest | cut -d: -f1`
			destport=`echo $dest | cut -d: -f2`
			ctdb killtcp $srcip:$srcport $destip:$destport >/dev/null 2>&1 
			ctdb killtcp $destip:$destport $srcip:$srcport >/dev/null 2>&1
		done
	} > /dev/null 2>&1
	/bin/rm -f /etc/ctdb/state/nfs/restart

	# if we have taken or released any ips we must send out
	# statd notifications to recover lost nfs locks
	[ -x /etc/ctdb/statd-callout ] && [ -f /etc/ctdb/state/statd/restart ] && {
		/etc/ctdb/statd-callout notify &
	} >/dev/null 2>&1

	/bin/rm -f /etc/ctdb/state/statd/restart
	;;

      monitor)
	# check that NFS responds to rpc requests
	ctdb_check_rpc "NFS" 100003 3
	ctdb_check_rpc "mount" 100005 1

	# and that its directories are available
	nfs_dirs=`grep -v '^#' < /etc/exports | cut -d' ' -f1`
	ctdb_check_directories "nfs" $nfs_dirs

	# check that lockd responds to rpc requests
	ctdb_check_rpc "statd" 100024 1
	ctdb_check_rpc "lockd" 100021 1
	ctdb_check_directories "statd" $STATD_SHARED_DIRECTORY
	;;

esac

exit 0

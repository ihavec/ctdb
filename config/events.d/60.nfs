#!/bin/sh
# script to manage nfs in a clustered environment

start_nfs() {
	/bin/mkdir -p $CTDB_VARDIR/state/nfs
	/bin/mkdir -p $CTDB_VARDIR/state/statd/ip
	startstop_nfs stop
	startstop_nfs start
	echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle
}

. $CTDB_BASE/functions

service_name="nfs"
service_start="start_nfs"
service_stop="startstop_nfs stop"

loadconfig

[ "$NFS_SERVER_MODE" != "GANESHA" ] || exit 0

ctdb_start_stop_service

is_ctdb_managed_service || exit 0

case "$1" in 
     init)
	# read statd from persistent database
	;;
     startup)
	ctdb_service_start
	mkdir -p $CTDB_VARDIR/state/statd
	touch $CTDB_VARDIR/state/statd/update-trigger
	;;

     shutdown)
	ctdb_service_stop
	;;

     takeip)
	ctdb_service_set_reconfigure
	;;

     releaseip)
	ctdb_service_set_reconfigure
	;;

      monitor)
	if ctdb_service_needs_reconfigure ; then
	    ctdb_service_reconfigure
	    exit 0
	fi

	update_tickles 2049

	# check that statd responds to rpc requests
	# if statd is not running we try to restart it
	if ctdb_check_rpc "STATD" 100024 1 >/dev/null ; then
		(service_name="nfs_statd"; ctdb_counter_init)
	else
		p="rpc.statd" ; cmd="$p"
		cmd="${cmd}${STATD_HOSTNAME:+ -n }${STATD_HOSTNAME}"
		cmd="${cmd}${STATD_PORT:+ -p }${STATD_PORT}"
		cmd="${cmd}${STATD_OUTGOING_PORT:+ -o }${STATD_OUTGOING_PORT}"
		(
			service_name="nfs_statd"
			ctdb_counter_incr
			ctdb_check_counter_limit 10 quiet >/dev/null
		) || {
			echo "$ctdb_check_rpc_out"
			echo "Trying to restart STATD [$cmd]"
		}
		$cmd
	fi


	# check that NFS responds to rpc requests
	[ "$CTDB_NFS_SKIP_KNFSD_ALIVE_CHECK" = "yes" ] || {
	    if ctdb_check_rpc "NFS" 100003 3 >/dev/null ; then
		(service_name="nfs_knfsd"; ctdb_counter_init)
	    else
		(
			service_name="nfs_knfsd"
			ctdb_counter_incr

			ctdb_check_counter_equal 10 || {
				echo "Trying to restart NFS service"
				startstop_nfs restart >/dev/null 2>&1 &
				exit 0
			}

			ctdb_check_counter_limit 15 quiet >/dev/null
		) || {
			echo "$ctdb_check_rpc_out"
			echo "Trying to restart NFS service"
			startstop_nfs restart
			exit 1
		}
	    fi
	}

	# and that its directories are available
	[ "$CTDB_NFS_SKIP_SHARE_CHECK" = "yes" ] || {
	    exportfs | grep -v '^#' | grep '^/' |
	    sed -e 's/[[:space:]]\+[^[:space:]]*$//' |
	    ctdb_check_directories
	} || exit $?

	# check that lockd responds to rpc requests
	ctdb_check_rpc "LOCKD" 100021 1 || {
		echo "Trying to restart lock manager service"
		startstop_nfs restart
		startstop_nfslock restart
		exit 1
	}

	# mount needs special handling since it is sometimes not started
	# correctly on RHEL5
	if ctdb_check_rpc "MOUNTD" 100005 1 >/dev/null ; then
		(service_name="nfs_mountd"; ctdb_counter_init)
	else
	(
		service_name="nfs_mountd"
		ctdb_counter_incr

		ctdb_check_counter_equal 5 || {
			p="rpc.mountd"
			cmd="${p}${MOUNTD_PORT:+ -p }${MOUNTD_PORT}"
			echo "Trying to restart MOUNTD [${cmd}]"
			killall -q -9 $p
			$cmd &
			exit 0
		}

		ctdb_check_counter_limit 10 quiet >/dev/null
	) || {
		echo "$ctdb_check_rpc_out"
		p="rpc.mountd"
		cmd="${p}${MOUNTD_PORT:+ -p }${MOUNTD_PORT}"
		echo "Trying to restart MOUNTD [${cmd}]"
		killall -q -9 $p
		$cmd &
		exit 1
	}
	fi


	# rquotad needs special handling since it is sometimes not started
	# correctly on RHEL5
	# this is not a critical service so we dont flag the node as unhealthy
	ctdb_check_rpc "RQUOTAD" 100011 1 || {
		p="rpc.rquotad"
		cmd="${p}${RQUOTAD_PORT:+ -p }${RQUOTAD_PORT}"
		echo "Trying to restart RQUOTAD [${cmd}]"
		killall -q -9 $p
		$cmd &
	}

	# once every 60 seconds, update the statd state database for which
	# clients need notifications
	LAST_UPDATE=`stat --printf="%Y" $CTDB_VARDIR/state/statd/update-trigger 2>/dev/null`
	CURRENT_TIME=`date +"%s"`
	[ $CURRENT_TIME -ge $(($LAST_UPDATE + 60)) ] && {
	    mkdir -p $CTDB_VARDIR/state/statd
	    touch $CTDB_VARDIR/state/statd/update-trigger
	    $CTDB_BASE/statd-callout updatelocal &
	    $CTDB_BASE/statd-callout updateremote &
	}
       	;;

    ipreallocated)
	# if the ips have been reallocated, we must restart the lockmanager
	# across all nodes and ping all statd listeners
	[ -x $CTDB_BASE/statd-callout ] && {
		$CTDB_BASE/statd-callout notify &
	} >/dev/null 2>&1
	;;
    *)
	ctdb_standard_event_handler "$@"
	;;
esac

exit 0
